#version 430 core

// a work group will accumulate over WORK_SIZE values
#define WORK_SIZE 1024

layout(local_size_x = WORK_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 0) buffer b_culled {
  int culled_instances[]; // length n
};
layout(std430, binding = 1) buffer b_runningSum {
  int running_sum[]; // length 2n
};
layout(std430, binding = 2) buffer b_totals {
  int totals[]; // length 2n/1024, in this shader it may as well be n/1024 = the group count
};

uniform uint N;

void main()
{
  uint tid = gl_LocalInvocationID.x + gl_WorkGroupID.x * gl_WorkGroupSize.x;
  running_sum[tid] = culled_instances[tid];

  // upon execution the first half of running_sum is filled with the
  // raw values that we are accumulating on

  int ino = 0;
  for (int o = 1; o < WORK_SIZE; o <<= 1) {
    memoryBarrierShared();
    barrier();
    if (tid - o >= 0)
      running_sum[(1 - ino) * N + tid] = running_sum[ino * N + tid] + running_sum[ino * N + tid - o];
    else
      running_sum[(1 - ino) * N + tid] = running_sum[ino * N + tid];
    ino = 1 - ino;
  }

  memoryBarrierShared();barrier(); // unecessary, the thread is reading from values *it* just wrote
  running_sum[tid] = running_sum[ino * N + tid];

  // save the total block size
  if (gl_LocalInvocationID.x == WORK_SIZE - 1)
    totals[gl_WorkGroupID.x] = running_sum[tid];
}